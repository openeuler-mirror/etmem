From fee91c2853f346d5222bf818930182b7b05b0e9f Mon Sep 17 00:00:00 2001
From: Kemeng Shi <shikemeng@huawei.com>
Date: Tue, 11 May 2021 22:44:06 +0800
Subject: [PATCH 29/50] accept advise

Signed-off-by: Kemeng Shi <shikemeng@huawei.com>
---
 src/etmemd_src/etmemd_common.c |  2 +-
 src/etmemd_src/etmemd_cslide.c |  2 +-
 src/etmemd_src/etmemd_log.c    |  6 ++----
 src/etmemd_src/etmemd_scan.c   | 23 ++++++++++++++++++++++-
 4 files changed, 26 insertions(+), 7 deletions(-)

diff --git a/src/etmemd_src/etmemd_common.c b/src/etmemd_src/etmemd_common.c
index 59933c4..e1cb1dd 100644
--- a/src/etmemd_src/etmemd_common.c
+++ b/src/etmemd_src/etmemd_common.c
@@ -32,7 +32,7 @@
 #include "etmemd_rpc.h"
 #include "etmemd_log.h"
 
-#define IDLE_SCAN_MAGIC         0X66
+#define IDLE_SCAN_MAGIC         0x66
 #define IDLE_SCAN_ADD_FLAGS     _IOW(IDLE_SCAN_MAGIC, 0x0, unsigned int)
 #define IDLE_SCAN_REMOVE_FLAGS  _IOW(IDLE_SCAN_MAGIC, 0x1, unsigned int)
 
diff --git a/src/etmemd_src/etmemd_cslide.c b/src/etmemd_src/etmemd_cslide.c
index 9a2ab04..6f609b8 100644
--- a/src/etmemd_src/etmemd_cslide.c
+++ b/src/etmemd_src/etmemd_cslide.c
@@ -1937,7 +1937,7 @@ static int fill_task_scan_flags(void *obj, void *val)
     } else if (strcmp(ign_host, "no") != 0) {
         etmemd_log(ETMEMD_LOG_ERR, "ign_host : not support %s\n", ign_host);
         etmemd_log(ETMEMD_LOG_ERR, "ign_host : only support yes/no\n");
-        return -1;
+        ret = -1;
     }
 
     free(val);
diff --git a/src/etmemd_src/etmemd_log.c b/src/etmemd_src/etmemd_log.c
index 5d7dece..0ffcc20 100644
--- a/src/etmemd_src/etmemd_log.c
+++ b/src/etmemd_src/etmemd_log.c
@@ -56,26 +56,24 @@ void etmemd_log(enum log_level log_level, const char *format, ...)
 
     va_start(args_in, format);
 
+    openlog("[etmemd] ", LOG_PID, LOG_USER);
     switch (log_level) {
         case ETMEMD_LOG_DEBUG:
-            openlog("[etmemd] ", LOG_PID, LOG_USER);
             vsyslog(LOG_DEBUG, format, args_in);
             break;
         case ETMEMD_LOG_INFO:
-            openlog("[etmemd] ", LOG_PID, LOG_USER);
             vsyslog(LOG_INFO, format, args_in);
             break;
         case ETMEMD_LOG_WARN:
-            openlog("[etmemd] ", LOG_PID, LOG_USER);
             vsyslog(LOG_WARNING, format, args_in);
             break;
         case ETMEMD_LOG_ERR:
-            openlog("[etmemd] ", LOG_PID, LOG_USER);
             vsyslog(LOG_ERR, format, args_in);
             break;
         default:
             va_end(args_in);
             printf("log_level is invalid, please check!\n");
+            closelog();
             return;
     }
 
diff --git a/src/etmemd_src/etmemd_scan.c b/src/etmemd_src/etmemd_scan.c
index ba0cf5e..c287c48 100644
--- a/src/etmemd_src/etmemd_scan.c
+++ b/src/etmemd_src/etmemd_scan.c
@@ -34,6 +34,7 @@
 #define PMD_IDLE_PTES_PARAMETER 512
 #define VMFLAG_MAX_LEN 100
 #define VMFLAG_MAX_NUM 30
+#define VMFLAG_VALID_LEN 2
 
 static bool g_exp_scan_inited = false;
 
@@ -272,6 +273,7 @@ static bool is_vma_with_vmflags(FILE *fp, char *vmflags_array[], int vmflags_num
     char parse_line[FILE_LINE_MAX_LEN];
     size_t len;
     int i;
+    char *flags_start = NULL;
 
     len = strlen(VMFLAG_HEAD);
     while (fgets(parse_line, FILE_LINE_MAX_LEN - 1, fp) != NULL) {
@@ -283,9 +285,10 @@ static bool is_vma_with_vmflags(FILE *fp, char *vmflags_array[], int vmflags_num
             continue;
         }
 
+        flags_start = strstr(parse_line, ":");
         /* check any flag in flags is set */
         for (i = 0; i < vmflags_num; i++) {
-            if (strstr(parse_line, vmflags_array[i]) == NULL) {
+            if (strstr(flags_start + 1, vmflags_array[i]) == NULL) {
                 return false;
             }
         }
@@ -405,6 +408,20 @@ struct vmas *get_vmas(const char *pid)
     return get_vmas_with_flags(pid, NULL, 0, true);
 }
 
+static bool is_flag_valid(char *flag)
+{
+    if (strstr(flag, " ") != NULL) {
+        etmemd_log(ETMEMD_LOG_ERR, "flag %s include space\n", flag);
+        return false;
+    }
+    if (strlen(flag) != VMFLAG_VALID_LEN) {
+        etmemd_log(ETMEMD_LOG_ERR, "flag %s len is not 2\n", flag);
+        return false;
+    }
+
+    return true;
+}
+
 struct vmas *etmemd_get_vmas(const char *pid, char *vmflags_array[], int vmflags_num, bool is_anon_only)
 {
     int i;
@@ -419,6 +436,10 @@ struct vmas *etmemd_get_vmas(const char *pid, char *vmflags_array[], int vmflags
             etmemd_log(ETMEMD_LOG_ERR, "etmemd_get_vmas vmflags_array[%d] is NULL\n", i);
             return NULL;
         }
+        if (!is_flag_valid(vmflags_array[i])) {
+            etmemd_log(ETMEMD_LOG_ERR, "etmemd_get_vmas flag %s invalid\n", vmflags_array[i]);
+            return NULL;
+        }
     }
 
     return get_vmas_with_flags(pid, vmflags_array, vmflags_num, is_anon_only);
-- 
2.27.0

