From f4b6e6e9e15d7bfb3e82d7b5a59157adf49fc426 Mon Sep 17 00:00:00 2001
From: liubo <liubo254@huawei.com>
Date: Wed, 8 Dec 2021 16:11:36 +0800
Subject: [PATCH 07/33] add code of testcase for etmem common function

---
 .../test/etmem_common_func_llt_test/CMakeLists.txt |  27 ++
 .../etmem_common_func_llt.c                        | 315 ++++++++++++++
 .../test_systemd_service.sh                        |  35 ++
 .../test/etmem_project_ops_llt_test/CMakeLists.txt |  28 ++
 .../etmem_project_ops_llt.c                        | 468 +++++++++++++++++++++
 etmem/test/project/CMakeLists.txt                  |  28 --
 etmem/test/project/etmem_project_ops_llt.c         | 468 ---------------------
 7 files changed, 873 insertions(+), 496 deletions(-)
 create mode 100644 etmem/test/etmem_common_func_llt_test/CMakeLists.txt
 create mode 100644 etmem/test/etmem_common_func_llt_test/etmem_common_func_llt.c
 create mode 100755 etmem/test/etmem_common_func_llt_test/test_systemd_service.sh
 create mode 100644 etmem/test/etmem_project_ops_llt_test/CMakeLists.txt
 create mode 100644 etmem/test/etmem_project_ops_llt_test/etmem_project_ops_llt.c
 delete mode 100644 etmem/test/project/CMakeLists.txt
 delete mode 100644 etmem/test/project/etmem_project_ops_llt.c

diff --git a/etmem/test/etmem_common_func_llt_test/CMakeLists.txt b/etmem/test/etmem_common_func_llt_test/CMakeLists.txt
new file mode 100644
index 0000000..be3b365
--- /dev/null
+++ b/etmem/test/etmem_common_func_llt_test/CMakeLists.txt
@@ -0,0 +1,27 @@
+# /******************************************************************************
+#  * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+#  * etmem is licensed under the Mulan PSL v2.
+#  * You can use this software according to the terms and conditions of the Mulan PSL v2.
+#  * You may obtain a copy of Mulan PSL v2 at:
+#  *     http://license.coscl.org.cn/MulanPSL2
+#  * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+#  * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+#  * PURPOSE.
+#  * See the Mulan PSL v2 for more details.
+#  * Author: liubo
+#  * Create: 2021-12-07
+#  * Description: CMakefileList for etmem_common_ops_llt to compile
+#  ******************************************************************************/
+
+project(etmem)
+
+INCLUDE_DIRECTORIES(../../inc/etmem_inc)
+INCLUDE_DIRECTORIES(../../inc/etmemd_inc)
+INCLUDE_DIRECTORIES(${GLIB2_INCLUDE_DIRS})
+
+SET(EXE etmem_common_func_llt)
+
+add_executable(${EXE}
+etmem_common_func_llt.c)
+
+target_link_libraries(${EXE} cunit ${BUILD_DIR}/lib/libetmemd.so pthread dl rt boundscheck numa ${GLIB2_LIBRARIES})
diff --git a/etmem/test/etmem_common_func_llt_test/etmem_common_func_llt.c b/etmem/test/etmem_common_func_llt_test/etmem_common_func_llt.c
new file mode 100644
index 0000000..2bb5b11
--- /dev/null
+++ b/etmem/test/etmem_common_func_llt_test/etmem_common_func_llt.c
@@ -0,0 +1,315 @@
+/******************************************************************************
+ * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+ * etmem is licensed under the Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ * http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+ * PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Author: liubo
+ * Create: 2021-12-07
+ * Description: This is a source file of the unit test for common function in etmem.
+ ******************************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <stdbool.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include <CUnit/Basic.h>
+#include <CUnit/Automated.h>
+#include <CUnit/Console.h>
+
+#include "etmemd_common.h"
+#include "etmemd_engine.h"
+#include "etmemd_rpc.h"
+
+static void clean_flags(bool *ishelp)
+{
+    *ishelp = false;
+    optarg = NULL;
+    optind = 0;
+}
+
+static void test_parse_cmdline_error(void)
+{
+    bool is_help = false;
+    char *cmd[] = {"./etmemd"};
+    char *cmd_error_para[] = {"./etmemd", "-d"};
+    char *cmd_error_help[] = {"./etmemd", "help"};
+    char *cmd_err_help[] = {"./etmemd", "---help"};
+    char *cmd_error_log[] = {"./etmemd", "-l"};
+    char *cmd_lack_sock[] = {"./etmemd", "-l", "0"};
+    char *cmd_sock_lack_para[] = {"./etmemd", "-l", "0", "-s"};
+    char *cmd_sock_err[] = {"./etmemd", "-l", "0", "1", "-s"};
+    char *cmd_mul_log[] = {"./etmemd", "-l", "0", "-l", "0"};
+    char *cmd_mul_sock[] = {"./etmemd", "-s", "sock0", "-s", "sock1"};
+    char *cmd_para_too_long[] = {"./etmemd", "-l", "0", "-l", "0", "-s", "sock"};
+    char *cmd_para_redundant[] = {"./etmemd", "-l", "0", "-h", "-s", "sock"};
+    char *cmd_lack_s[] = {"./etmemd", "-l", "0", "-h"};
+    char *cmd_unwanted_para[] = {"./etmemd", "-l", "0", "-d", "file"};
+
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(0, NULL, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd) / sizeof(cmd[0]), cmd, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_error_para) / sizeof(cmd_error_para[0]), cmd_error_para, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_error_help) / sizeof(cmd_error_help[0]), cmd_error_help, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_err_help) / sizeof(cmd_err_help[0]), cmd_err_help, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_error_log) / sizeof(cmd_error_log[0]), cmd_error_log, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_lack_sock) / sizeof(cmd_lack_sock[0]), cmd_lack_sock, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_sock_lack_para) / sizeof(cmd_sock_lack_para[0]), cmd_sock_lack_para, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_sock_err) / sizeof(cmd_sock_err[0]), cmd_sock_err, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_mul_log) / sizeof(cmd_mul_log[0]), cmd_mul_log, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_mul_sock) / sizeof(cmd_mul_sock[0]), cmd_mul_sock, &is_help), -1);
+    etmemd_sock_name_free();
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_para_too_long) / sizeof(cmd_para_too_long[0]), cmd_para_too_long, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_para_redundant) / sizeof(cmd_para_redundant[0]), cmd_para_redundant, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_lack_s) / sizeof(cmd_lack_s[0]), cmd_lack_s, &is_help), -1);
+    clean_flags(&is_help);
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_unwanted_para) / sizeof(cmd_unwanted_para[0]), cmd_unwanted_para, &is_help), -1);
+    clean_flags(&is_help);
+}
+
+static void test_parse_cmdline_ok(void)
+{
+    bool is_help = false;
+    char *cmd[] = {"./etmemd", "-h"};
+    char *cmd_h[] = {"./etmemd", "-help"};
+    char *cmd_help[] = {"./etmemd", "--help"};
+    char *cmd_ok[] = {"./etmemd", "-l", "0", "-s", "cmd_ok"};
+    char *cmd_only_sock[] = {"./etmemd", "-s", "cmd_only_sock"};
+
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd) / sizeof(cmd[0]), cmd, &is_help), 0);
+    etmemd_sock_name_free();
+    clean_flags(&is_help);
+
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_ok) / sizeof(cmd_ok[0]), cmd_ok, &is_help), 0);
+    clean_flags(&is_help);
+
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_h) / sizeof(cmd_h[0]), cmd_h, &is_help), 0);
+    clean_flags(&is_help);
+
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_help) / sizeof(cmd_help[0]), cmd_help, &is_help), 0);
+    clean_flags(&is_help);
+
+    CU_ASSERT_EQUAL(etmemd_parse_cmdline(sizeof(cmd_only_sock) / sizeof(cmd_only_sock[0]), cmd_only_sock, &is_help), 0);
+    etmemd_sock_name_free();
+    clean_flags(&is_help);
+}
+
+static void test_get_int_value_error(void)
+{
+    int value;
+
+    CU_ASSERT_EQUAL(get_int_value("a1", &value), -1);
+    CU_ASSERT_EQUAL(get_int_value("-2147483649", &value), -1);
+    CU_ASSERT_EQUAL(get_int_value("2147483648", &value), -1);
+}
+
+static void test_get_int_value_ok(void)
+{
+    int value;
+
+    CU_ASSERT_EQUAL(get_int_value("-2147483648", &value), 0);
+    CU_ASSERT_EQUAL(value, INT_MIN);
+    CU_ASSERT_EQUAL(get_int_value("-2147483647", &value), 0);
+    CU_ASSERT_EQUAL(value, INT_MIN + 1);
+    CU_ASSERT_EQUAL(get_int_value("0", &value), 0);
+    CU_ASSERT_EQUAL(value, 0);
+    CU_ASSERT_EQUAL(get_int_value("2147483646", &value), 0);
+    CU_ASSERT_EQUAL(value, INT_MAX - 1);
+    CU_ASSERT_EQUAL(get_int_value("2147483647", &value), 0);
+    CU_ASSERT_EQUAL(value, INT_MAX);
+}
+
+static void test_get_uint_value_error(void)
+{
+    unsigned int value;
+
+    CU_ASSERT_EQUAL(get_unsigned_int_value("a1", &value), -1);
+    CU_ASSERT_EQUAL(get_unsigned_int_value("-1", &value), -1);
+    CU_ASSERT_EQUAL(get_unsigned_int_value("4294967296", &value), -1);
+}
+
+static void test_get_uint_value_ok(void)
+{
+    unsigned int value;
+
+    CU_ASSERT_EQUAL(get_unsigned_int_value("0", &value), 0);
+    CU_ASSERT_EQUAL(value, 0);
+    CU_ASSERT_EQUAL(get_unsigned_int_value("1", &value), 0);
+    CU_ASSERT_EQUAL(value, 1);
+    CU_ASSERT_EQUAL(get_unsigned_int_value("4294967294", &value), 0);
+    CU_ASSERT_EQUAL(value, UINT_MAX - 1);
+    CU_ASSERT_EQUAL(get_unsigned_int_value("4294967295", &value), 0);
+    CU_ASSERT_EQUAL(value, UINT_MAX);
+}
+
+static void test_get_proc_file_error(void)
+{
+    CU_ASSERT_PTR_NULL(etmemd_get_proc_file("0", "/maps", 0, "r"));
+    CU_ASSERT_PTR_NULL(etmemd_get_proc_file("1", "maps", 0, "r"));
+    CU_ASSERT_PTR_NULL(etmemd_get_proc_file("1", "/map", 0, "r"));
+}
+
+static void test_get_proc_file_ok(void)
+{
+    FILE *fp = NULL;
+
+    fp = etmemd_get_proc_file("1", "/maps", 0, "r");
+
+    CU_ASSERT_EQUAL(fclose(fp), 0);
+}
+
+static void test_get_key_value_error(void)
+{
+    char key[KEY_VALUE_MAX_LEN] = {};
+    char value[KEY_VALUE_MAX_LEN] = {};
+
+    CU_ASSERT_EQUAL(get_keyword_and_value("", key, value), -1);
+    CU_ASSERT_EQUAL(get_keyword_and_value("abcd", key, value), -1);
+    CU_ASSERT_EQUAL(get_keyword_and_value(":1", key, value), -1);
+    CU_ASSERT_EQUAL(get_keyword_and_value("a:", key, value), -1);
+    CU_ASSERT_EQUAL(get_keyword_and_value("#a:1", key, value), -1);
+    CU_ASSERT_EQUAL(get_keyword_and_value("a.b:1", key, value), -1);
+    CU_ASSERT_EQUAL(get_keyword_and_value("loop:2*4", key, value), -1);
+}
+
+static void test_get_key_value_ok(void)
+{
+    char key[KEY_VALUE_MAX_LEN] = {};
+    char value[KEY_VALUE_MAX_LEN] = {};
+
+    CU_ASSERT_EQUAL(get_keyword_and_value("loop:30", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "loop");
+    CU_ASSERT_STRING_EQUAL(value, "30");
+    CU_ASSERT_EQUAL(get_keyword_and_value("loop 30", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "loop");
+    CU_ASSERT_STRING_EQUAL(value, "30");
+    CU_ASSERT_EQUAL(get_keyword_and_value("loop\t30", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "loop");
+    CU_ASSERT_STRING_EQUAL(value, "30");
+    CU_ASSERT_EQUAL(get_keyword_and_value("loop :30", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "loop");
+    CU_ASSERT_STRING_EQUAL(value, "30");
+    CU_ASSERT_EQUAL(get_keyword_and_value("loop\t:30", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "loop");
+    CU_ASSERT_STRING_EQUAL(value, "30");
+    CU_ASSERT_EQUAL(get_keyword_and_value("loop\t 30", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "loop");
+    CU_ASSERT_STRING_EQUAL(value, "30");
+    CU_ASSERT_EQUAL(get_keyword_and_value("a_b:1", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "a_b");
+    CU_ASSERT_STRING_EQUAL(value, "1");
+    CU_ASSERT_EQUAL(get_keyword_and_value("%P:1", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "%P");
+    CU_ASSERT_STRING_EQUAL(value, "1");
+    CU_ASSERT_EQUAL(get_keyword_and_value("%P:0.2", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "%P");
+    CU_ASSERT_STRING_EQUAL(value, "0.2");
+    CU_ASSERT_EQUAL(get_keyword_and_value("%P:20%", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "%P");
+    CU_ASSERT_STRING_EQUAL(value, "20%");
+    CU_ASSERT_EQUAL(get_keyword_and_value("output:/var/run", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "output");
+    CU_ASSERT_STRING_EQUAL(value, "/var/run");
+    CU_ASSERT_EQUAL(get_keyword_and_value("engine:dynamic_fb", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "engine");
+    CU_ASSERT_STRING_EQUAL(value, "dynamic_fb");
+    CU_ASSERT_EQUAL(get_keyword_and_value("name:qemu-kvm", key, value), 0);
+    CU_ASSERT_STRING_EQUAL(key, "name");
+    CU_ASSERT_STRING_EQUAL(value, "qemu-kvm");
+}
+
+typedef enum {
+    CUNIT_SCREEN = 0,
+    CUNIT_XMLFILE,
+    CUNIT_CONSOLE
+} cu_run_mode;
+
+void test_etmem_systemd_service_0001(void)
+{
+    CU_ASSERT_EQUAL(system("../etmem_common_func_llt_test/test_systemd_service.sh"), 0);
+}
+
+int main(int argc, const char **argv)
+{
+    CU_pSuite suite;
+    CU_pTest pTest;
+    unsigned int num_failures;
+    cu_run_mode cunit_mode = CUNIT_SCREEN;
+    int error_num;
+
+    if (argc > 1) {
+        cunit_mode = atoi(argv[1]);
+    }
+
+    if (CU_initialize_registry() != CUE_SUCCESS) {
+        return -CU_get_error();
+    }
+
+    suite = CU_add_suite("etmem_common_func", NULL, NULL);
+    if (suite == NULL) {
+        goto ERROR;
+    }
+
+    if (CU_ADD_TEST(suite, test_get_int_value_error) == NULL ||
+        CU_ADD_TEST(suite, test_get_int_value_ok) == NULL ||
+        CU_ADD_TEST(suite, test_get_uint_value_error) == NULL ||
+        CU_ADD_TEST(suite, test_get_uint_value_ok) == NULL ||
+        CU_ADD_TEST(suite, test_get_key_value_error) == NULL ||
+        CU_ADD_TEST(suite, test_get_key_value_ok) == NULL ||
+        CU_ADD_TEST(suite, test_parse_cmdline_error) == NULL ||
+        CU_ADD_TEST(suite, test_parse_cmdline_ok) == NULL ||
+        CU_ADD_TEST(suite, test_get_proc_file_error) == NULL ||
+        CU_ADD_TEST(suite, test_get_proc_file_ok) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_systemd_service_0001) == NULL) {
+            printf("CU_ADD_TEST fail. \n");
+            goto ERROR;
+    }
+
+    switch (cunit_mode) {
+        case CUNIT_SCREEN:
+            CU_basic_set_mode(CU_BRM_VERBOSE);
+            CU_basic_run_tests();
+            break;
+        case CUNIT_XMLFILE:
+            CU_set_output_filename("etmemd_common.c");
+            CU_automated_run_tests();
+            break;
+        case CUNIT_CONSOLE:
+            CU_console_run_tests();
+            break;
+        default:
+            printf("not support cunit mode, only support: 0 or 1\n");
+            goto ERROR;
+    }
+
+    num_failures = CU_get_number_of_failures();
+    CU_cleanup_registry();
+    return num_failures;
+
+ERROR:
+    error_num = CU_get_error();
+    CU_cleanup_registry();
+    return -error_num;
+}
diff --git a/etmem/test/etmem_common_func_llt_test/test_systemd_service.sh b/etmem/test/etmem_common_func_llt_test/test_systemd_service.sh
new file mode 100755
index 0000000..852ad8c
--- /dev/null
+++ b/etmem/test/etmem_common_func_llt_test/test_systemd_service.sh
@@ -0,0 +1,35 @@
+# /******************************************************************************
+#  * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+#  * etmem is licensed under the Mulan PSL v2.
+#  * You can use this software according to the terms and conditions of the Mulan PSL v2.
+#  * You may obtain a copy of Mulan PSL v2 at:
+#  *     http://license.coscl.org.cn/MulanPSL2
+#  * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+#  * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+#  * PURPOSE.
+#  * See the Mulan PSL v2 for more details.
+#  * Author: liubo
+#  * Create: 2021-12-07
+#  * Description: This is a shell script of the unit test for etmem commont functions
+#  ******************************************************************************/
+
+test_start_as_service()
+{
+    ./bin/etmemd -l 0 -s dt_socket -m &
+    etmemd_pid=$!
+    echo "etmemd_pid ${etmemd_pid}"
+    sleep 1
+    ./bin/etmem obj add -f ../conf/conf_slide/config_file -s dt_socket
+    if [ "$?" != "0" ];then
+        echo "add config fail to etmemd service unexpected"
+        exit 1
+    fi
+    ps -aux |grep -v grep |grep "etmemd -l 0 -s dt_socket -m"
+    if [ "$?" != "0" ];then
+        echo "etmemd service exit unexpected after add config"
+        exit 1
+    fi
+    killall etmemd
+}
+
+test_start_as_service
diff --git a/etmem/test/etmem_project_ops_llt_test/CMakeLists.txt b/etmem/test/etmem_project_ops_llt_test/CMakeLists.txt
new file mode 100644
index 0000000..70cd530
--- /dev/null
+++ b/etmem/test/etmem_project_ops_llt_test/CMakeLists.txt
@@ -0,0 +1,28 @@
+# /******************************************************************************
+#  * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+#  * etmem is licensed under the Mulan PSL v2.
+#  * You can use this software according to the terms and conditions of the Mulan PSL v2.
+#  * You may obtain a copy of Mulan PSL v2 at:
+#  *     http://license.coscl.org.cn/MulanPSL2
+#  * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+#  * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+#  * PURPOSE.
+#  * See the Mulan PSL v2 for more details.
+#  * Author: liubo
+#  * Create: 2021-11-29
+#  * Description: CMakefileList for etmem_project_ops_llt to compile
+#  ******************************************************************************/
+
+project(etmem)
+
+INCLUDE_DIRECTORIES(../../inc/etmem_inc)
+INCLUDE_DIRECTORIES(../../inc/etmemd_inc)
+INCLUDE_DIRECTORIES(../common)
+INCLUDE_DIRECTORIES(${GLIB2_INCLUDE_DIRS})
+
+SET(EXE etmem_project_ops_llt)
+
+add_executable(${EXE}
+etmem_project_ops_llt.c)
+
+target_link_libraries(${EXE} cunit ${BUILD_DIR}/lib/libetmemd.so ${BUILD_DIR}/lib/libtest.so pthread dl rt boundscheck numa ${GLIB2_LIBRARIES})
diff --git a/etmem/test/etmem_project_ops_llt_test/etmem_project_ops_llt.c b/etmem/test/etmem_project_ops_llt_test/etmem_project_ops_llt.c
new file mode 100644
index 0000000..edd2330
--- /dev/null
+++ b/etmem/test/etmem_project_ops_llt_test/etmem_project_ops_llt.c
@@ -0,0 +1,468 @@
+/******************************************************************************
+ * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+ * etmem is licensed under the Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ * http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+ * PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Author: liubo
+ * Create: 2021-11-29
+ * Description: This is a source file of the unit test for project-related commands in etmem.
+ ******************************************************************************/
+
+#include <sys/file.h>
+#include <sys/sysinfo.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <limits.h>
+#include <glib.h>
+
+#include "etmemd_project.h"
+#include "etmemd_file.h"
+#include "etmemd_common.h"
+#include "securec.h"
+
+#include "test_common.h"
+
+#include <CUnit/Basic.h>
+#include <CUnit/Automated.h>
+#include <CUnit/Console.h>
+
+#define PROJECT_ADD_TEST_MAX_NUM 50
+
+static struct proj_test_param g_proj_test_param;
+
+static void etmem_pro_add_name(void)
+{
+    const char *project_name_long = "project name cannot longer than 32 ppmpppppppppppppppppppppppppppppppppppppppppppppp";
+    GKeyFile *config = NULL;
+    struct proj_test_param param;
+
+    init_proj_param(&param);
+
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_PRO_EXISTED);
+    destroy_proj_config(config);
+
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.proj_name = "";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.proj_name = project_name_long;
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.proj_name = DEFAULT_PROJ;
+}
+
+static void etmem_pro_add_interval(void)
+{
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    param.interval = "0";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.interval = "1";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.interval = "2";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.interval = "1199";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.interval = "1200";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.interval = "1201";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.interval = "abc";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+}
+
+static void etmem_pro_add_loop(void)
+{
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    param.loop = "0";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.loop = "1";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.loop = "2";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.loop = "119";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.loop = "120";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.loop = "121";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.loop = "abc";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+}
+
+static void etmem_pro_add_sleep(void)
+{
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    param.sleep = "0";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.sleep = "1";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.sleep = "2";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.sleep = "1199";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.sleep = "1200";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.sleep = "1201";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+
+    param.sleep = "wrong sleep type";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+}
+
+static void etmem_pro_lack_loop(void)
+{
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    param.loop = NULL;
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
+    destroy_proj_config(config);
+}
+
+void test_etmem_prj_add_error(void)
+{
+    etmem_pro_add_name();
+    etmem_pro_add_interval();
+    etmem_pro_add_loop();
+    etmem_pro_add_sleep();
+    etmem_pro_lack_loop();
+}
+
+void test_etmem_prj_del_error(void)
+{
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    param.proj_name = "";
+    config = construct_proj_config(&param);
+    CU_ASSERT_NOT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    param.proj_name = "noexist";
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_PRO_NOEXIST);
+    destroy_proj_config(config);
+}
+
+static void add_project_once(void)
+{
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    CU_ASSERT_EQUAL(etmemd_project_show(NULL, 0), OPT_PRO_NOEXIST);
+
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    CU_ASSERT_EQUAL(etmemd_project_show(NULL, 0), OPT_SUCCESS);
+
+    config = construct_proj_config(&param);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+    destroy_proj_config(config);
+
+    CU_ASSERT_EQUAL(etmemd_project_show("noexist", 0), OPT_PRO_NOEXIST);
+}
+
+static int add_project_multiple(int proj_add_num)
+{
+    char project_name_str[PROJECT_NAME_MAX_LEN] = {0};
+    unsigned int project_num;
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    for (project_num = 0; project_num < proj_add_num; project_num++) {
+        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
+            project_num) <= 0) {
+            printf("get project_name wrong.\n");
+            return -1;
+        }
+        param.proj_name = project_name_str;
+        config = construct_proj_config(&param);
+        CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+        destroy_proj_config(config);
+    }
+
+    CU_ASSERT_EQUAL(etmemd_project_show(NULL, 0), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_show("project_add_del_test_num5", 0), OPT_SUCCESS);
+
+    for (project_num = 0; project_num < proj_add_num; project_num++) {
+        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
+            project_num) <= 0) {
+            printf("get project_name wrong.\n");
+            return -1;
+        }
+        param.proj_name = project_name_str;
+        config = construct_proj_config(&param);
+        CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+        destroy_proj_config(config);
+    }
+
+    return 0;
+}
+
+void test_etmem_project_add_ok(void)
+{
+    add_project_once();
+    CU_ASSERT_EQUAL(add_project_multiple(PROJECT_ADD_TEST_MAX_NUM), 0);
+}
+
+void test_etmem_mig_start_error(void)
+{
+    struct proj_test_param param;
+
+    init_proj_param(&param);
+
+    CU_ASSERT_EQUAL(etmemd_migrate_start(NULL), OPT_INVAL);
+    CU_ASSERT_EQUAL(etmemd_migrate_start(""), OPT_PRO_NOEXIST);
+    CU_ASSERT_EQUAL(etmemd_migrate_start("etmem"), OPT_PRO_NOEXIST);
+    CU_ASSERT_EQUAL(etmemd_migrate_start("me^$%*mig"), OPT_PRO_NOEXIST);
+ 
+    param.proj_name = "add_for_migrate_test";
+    do_add_proj_test(&param);
+
+    CU_ASSERT_EQUAL(etmemd_migrate_start("add_for_migrate_test"), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_start("add_for_migrate_test"), OPT_PRO_STARTED);
+
+    etmemd_stop_all_projects();
+}
+
+void test_etmem_mig_stop_error(void)
+{
+    struct proj_test_param param;
+
+    init_proj_param(&param);
+
+    CU_ASSERT_EQUAL(etmemd_migrate_stop(NULL), OPT_INVAL);
+    CU_ASSERT_EQUAL(etmemd_migrate_stop(""), OPT_PRO_NOEXIST);
+    CU_ASSERT_EQUAL(etmemd_migrate_stop("ETMEM"), OPT_PRO_NOEXIST);
+    CU_ASSERT_EQUAL(etmemd_migrate_stop("ET^$%*MEM"), OPT_PRO_NOEXIST);
+ 
+    param.proj_name = "add_for_migrate_stop_test";
+    do_add_proj_test(&param);
+
+    CU_ASSERT_EQUAL(etmemd_migrate_start("add_for_migrate_stop_test"), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_stop("add_for_migrate_stop_test"), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_stop("add_for_migrate_stop_test"), OPT_PRO_STOPPED);
+
+    etmemd_stop_all_projects();
+}
+
+static int start_project_multiple(int proj_add_num)
+{
+    char project_name_str[PROJECT_NAME_MAX_LEN] = {0};
+    unsigned int project_num;
+    struct proj_test_param param;
+    GKeyFile *config = NULL;
+
+    init_proj_param(&param);
+
+    for (project_num = 0; project_num < proj_add_num; project_num++) {
+        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
+            project_num) <= 0) {
+            printf("get project_name wrong.\n");
+            return -1;
+        }
+        param.proj_name = project_name_str;
+        config = construct_proj_config(&param);
+        CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
+        destroy_proj_config(config);
+        CU_ASSERT_EQUAL(etmemd_migrate_start(project_name_str), OPT_SUCCESS);
+    }
+
+    for (project_num = 0; project_num < proj_add_num; project_num++) {
+        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
+            project_num) <= 0) {
+            printf("get project_name wrong.\n");
+            return -1;
+        }
+        param.proj_name = project_name_str;
+        config = construct_proj_config(&param);
+        CU_ASSERT_EQUAL(etmemd_migrate_stop(project_name_str), OPT_SUCCESS);
+        CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
+        destroy_proj_config(config);
+    }
+
+    return 0;
+}
+
+void test_etmem_mig_start_ok(void)
+{
+    CU_ASSERT_EQUAL(start_project_multiple(1), 0);
+    CU_ASSERT_EQUAL(start_project_multiple(PROJECT_ADD_TEST_MAX_NUM), 0);
+}
+
+typedef enum {
+    CUNIT_SCREEN = 0,
+    CUNIT_XMLFILE,
+    CUNIT_CONSOLE
+} cu_run_mode;
+
+int main(int argc, const char **argv)
+{
+    CU_pSuite suite;
+    CU_pTest pTest;
+    unsigned int num_failures;
+    cu_run_mode cunit_mode = CUNIT_SCREEN;
+    int error_num;
+
+    if (argc > 1) {
+        cunit_mode = atoi(argv[1]);
+    }
+
+    if (CU_initialize_registry() != CUE_SUCCESS) {
+        return -CU_get_error();
+    }
+
+    suite = CU_add_suite("etmem_project_ops", NULL, NULL);
+    if (suite == NULL) {
+        goto ERROR;
+    }
+
+    if (CU_ADD_TEST(suite, test_etmem_prj_add_error) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_prj_del_error) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_project_add_ok) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_mig_start_error) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_mig_stop_error) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_mig_start_ok) == NULL) {
+            printf("CU_ADD_TEST fail. \n");
+            goto ERROR;
+    }
+
+    switch (cunit_mode) {
+        case CUNIT_SCREEN:
+            CU_basic_set_mode(CU_BRM_VERBOSE);
+            CU_basic_run_tests();
+            break;
+        case CUNIT_XMLFILE:
+            CU_set_output_filename("etmemd_project.c");
+            CU_automated_run_tests();
+            break;
+        case CUNIT_CONSOLE:
+            CU_console_run_tests();
+            break;
+        default:
+            printf("not support cunit mode, only support: 0 or 1\n");
+            goto ERROR;
+    }
+
+    num_failures = CU_get_number_of_failures();
+    CU_cleanup_registry();
+    return num_failures;
+
+ERROR:
+    error_num = CU_get_error();
+    CU_cleanup_registry();
+    return -error_num;
+}
diff --git a/etmem/test/project/CMakeLists.txt b/etmem/test/project/CMakeLists.txt
deleted file mode 100644
index 70cd530..0000000
--- a/etmem/test/project/CMakeLists.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-# /******************************************************************************
-#  * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
-#  * etmem is licensed under the Mulan PSL v2.
-#  * You can use this software according to the terms and conditions of the Mulan PSL v2.
-#  * You may obtain a copy of Mulan PSL v2 at:
-#  *     http://license.coscl.org.cn/MulanPSL2
-#  * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
-#  * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
-#  * PURPOSE.
-#  * See the Mulan PSL v2 for more details.
-#  * Author: liubo
-#  * Create: 2021-11-29
-#  * Description: CMakefileList for etmem_project_ops_llt to compile
-#  ******************************************************************************/
-
-project(etmem)
-
-INCLUDE_DIRECTORIES(../../inc/etmem_inc)
-INCLUDE_DIRECTORIES(../../inc/etmemd_inc)
-INCLUDE_DIRECTORIES(../common)
-INCLUDE_DIRECTORIES(${GLIB2_INCLUDE_DIRS})
-
-SET(EXE etmem_project_ops_llt)
-
-add_executable(${EXE}
-etmem_project_ops_llt.c)
-
-target_link_libraries(${EXE} cunit ${BUILD_DIR}/lib/libetmemd.so ${BUILD_DIR}/lib/libtest.so pthread dl rt boundscheck numa ${GLIB2_LIBRARIES})
diff --git a/etmem/test/project/etmem_project_ops_llt.c b/etmem/test/project/etmem_project_ops_llt.c
deleted file mode 100644
index edd2330..0000000
--- a/etmem/test/project/etmem_project_ops_llt.c
+++ /dev/null
@@ -1,468 +0,0 @@
-/******************************************************************************
- * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
- * etmem is licensed under the Mulan PSL v2.
- * You can use this software according to the terms and conditions of the Mulan PSL v2.
- * You may obtain a copy of Mulan PSL v2 at:
- * http://license.coscl.org.cn/MulanPSL2
- * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
- * PURPOSE.
- * See the Mulan PSL v2 for more details.
- * Author: liubo
- * Create: 2021-11-29
- * Description: This is a source file of the unit test for project-related commands in etmem.
- ******************************************************************************/
-
-#include <sys/file.h>
-#include <sys/sysinfo.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <limits.h>
-#include <glib.h>
-
-#include "etmemd_project.h"
-#include "etmemd_file.h"
-#include "etmemd_common.h"
-#include "securec.h"
-
-#include "test_common.h"
-
-#include <CUnit/Basic.h>
-#include <CUnit/Automated.h>
-#include <CUnit/Console.h>
-
-#define PROJECT_ADD_TEST_MAX_NUM 50
-
-static struct proj_test_param g_proj_test_param;
-
-static void etmem_pro_add_name(void)
-{
-    const char *project_name_long = "project name cannot longer than 32 ppmpppppppppppppppppppppppppppppppppppppppppppppp";
-    GKeyFile *config = NULL;
-    struct proj_test_param param;
-
-    init_proj_param(&param);
-
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_PRO_EXISTED);
-    destroy_proj_config(config);
-
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.proj_name = "";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.proj_name = project_name_long;
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.proj_name = DEFAULT_PROJ;
-}
-
-static void etmem_pro_add_interval(void)
-{
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    param.interval = "0";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.interval = "1";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.interval = "2";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.interval = "1199";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.interval = "1200";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.interval = "1201";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.interval = "abc";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-}
-
-static void etmem_pro_add_loop(void)
-{
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    param.loop = "0";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.loop = "1";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.loop = "2";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.loop = "119";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.loop = "120";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.loop = "121";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.loop = "abc";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-}
-
-static void etmem_pro_add_sleep(void)
-{
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    param.sleep = "0";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.sleep = "1";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.sleep = "2";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.sleep = "1199";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.sleep = "1200";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.sleep = "1201";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-
-    param.sleep = "wrong sleep type";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-}
-
-static void etmem_pro_lack_loop(void)
-{
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    param.loop = NULL;
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_INVAL);
-    destroy_proj_config(config);
-}
-
-void test_etmem_prj_add_error(void)
-{
-    etmem_pro_add_name();
-    etmem_pro_add_interval();
-    etmem_pro_add_loop();
-    etmem_pro_add_sleep();
-    etmem_pro_lack_loop();
-}
-
-void test_etmem_prj_del_error(void)
-{
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    param.proj_name = "";
-    config = construct_proj_config(&param);
-    CU_ASSERT_NOT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    param.proj_name = "noexist";
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_PRO_NOEXIST);
-    destroy_proj_config(config);
-}
-
-static void add_project_once(void)
-{
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    CU_ASSERT_EQUAL(etmemd_project_show(NULL, 0), OPT_PRO_NOEXIST);
-
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    CU_ASSERT_EQUAL(etmemd_project_show(NULL, 0), OPT_SUCCESS);
-
-    config = construct_proj_config(&param);
-    CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-    destroy_proj_config(config);
-
-    CU_ASSERT_EQUAL(etmemd_project_show("noexist", 0), OPT_PRO_NOEXIST);
-}
-
-static int add_project_multiple(int proj_add_num)
-{
-    char project_name_str[PROJECT_NAME_MAX_LEN] = {0};
-    unsigned int project_num;
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    for (project_num = 0; project_num < proj_add_num; project_num++) {
-        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
-            project_num) <= 0) {
-            printf("get project_name wrong.\n");
-            return -1;
-        }
-        param.proj_name = project_name_str;
-        config = construct_proj_config(&param);
-        CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-        destroy_proj_config(config);
-    }
-
-    CU_ASSERT_EQUAL(etmemd_project_show(NULL, 0), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_project_show("project_add_del_test_num5", 0), OPT_SUCCESS);
-
-    for (project_num = 0; project_num < proj_add_num; project_num++) {
-        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
-            project_num) <= 0) {
-            printf("get project_name wrong.\n");
-            return -1;
-        }
-        param.proj_name = project_name_str;
-        config = construct_proj_config(&param);
-        CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-        destroy_proj_config(config);
-    }
-
-    return 0;
-}
-
-void test_etmem_project_add_ok(void)
-{
-    add_project_once();
-    CU_ASSERT_EQUAL(add_project_multiple(PROJECT_ADD_TEST_MAX_NUM), 0);
-}
-
-void test_etmem_mig_start_error(void)
-{
-    struct proj_test_param param;
-
-    init_proj_param(&param);
-
-    CU_ASSERT_EQUAL(etmemd_migrate_start(NULL), OPT_INVAL);
-    CU_ASSERT_EQUAL(etmemd_migrate_start(""), OPT_PRO_NOEXIST);
-    CU_ASSERT_EQUAL(etmemd_migrate_start("etmem"), OPT_PRO_NOEXIST);
-    CU_ASSERT_EQUAL(etmemd_migrate_start("me^$%*mig"), OPT_PRO_NOEXIST);
- 
-    param.proj_name = "add_for_migrate_test";
-    do_add_proj_test(&param);
-
-    CU_ASSERT_EQUAL(etmemd_migrate_start("add_for_migrate_test"), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_migrate_start("add_for_migrate_test"), OPT_PRO_STARTED);
-
-    etmemd_stop_all_projects();
-}
-
-void test_etmem_mig_stop_error(void)
-{
-    struct proj_test_param param;
-
-    init_proj_param(&param);
-
-    CU_ASSERT_EQUAL(etmemd_migrate_stop(NULL), OPT_INVAL);
-    CU_ASSERT_EQUAL(etmemd_migrate_stop(""), OPT_PRO_NOEXIST);
-    CU_ASSERT_EQUAL(etmemd_migrate_stop("ETMEM"), OPT_PRO_NOEXIST);
-    CU_ASSERT_EQUAL(etmemd_migrate_stop("ET^$%*MEM"), OPT_PRO_NOEXIST);
- 
-    param.proj_name = "add_for_migrate_stop_test";
-    do_add_proj_test(&param);
-
-    CU_ASSERT_EQUAL(etmemd_migrate_start("add_for_migrate_stop_test"), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_migrate_stop("add_for_migrate_stop_test"), OPT_SUCCESS);
-    CU_ASSERT_EQUAL(etmemd_migrate_stop("add_for_migrate_stop_test"), OPT_PRO_STOPPED);
-
-    etmemd_stop_all_projects();
-}
-
-static int start_project_multiple(int proj_add_num)
-{
-    char project_name_str[PROJECT_NAME_MAX_LEN] = {0};
-    unsigned int project_num;
-    struct proj_test_param param;
-    GKeyFile *config = NULL;
-
-    init_proj_param(&param);
-
-    for (project_num = 0; project_num < proj_add_num; project_num++) {
-        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
-            project_num) <= 0) {
-            printf("get project_name wrong.\n");
-            return -1;
-        }
-        param.proj_name = project_name_str;
-        config = construct_proj_config(&param);
-        CU_ASSERT_EQUAL(etmemd_project_add(config), OPT_SUCCESS);
-        destroy_proj_config(config);
-        CU_ASSERT_EQUAL(etmemd_migrate_start(project_name_str), OPT_SUCCESS);
-    }
-
-    for (project_num = 0; project_num < proj_add_num; project_num++) {
-        if (snprintf_s(project_name_str, PROJECT_NAME_MAX_LEN, PROJECT_NAME_MAX_LEN - 1, "project_add_del_test_num%d",
-            project_num) <= 0) {
-            printf("get project_name wrong.\n");
-            return -1;
-        }
-        param.proj_name = project_name_str;
-        config = construct_proj_config(&param);
-        CU_ASSERT_EQUAL(etmemd_migrate_stop(project_name_str), OPT_SUCCESS);
-        CU_ASSERT_EQUAL(etmemd_project_remove(config), OPT_SUCCESS);
-        destroy_proj_config(config);
-    }
-
-    return 0;
-}
-
-void test_etmem_mig_start_ok(void)
-{
-    CU_ASSERT_EQUAL(start_project_multiple(1), 0);
-    CU_ASSERT_EQUAL(start_project_multiple(PROJECT_ADD_TEST_MAX_NUM), 0);
-}
-
-typedef enum {
-    CUNIT_SCREEN = 0,
-    CUNIT_XMLFILE,
-    CUNIT_CONSOLE
-} cu_run_mode;
-
-int main(int argc, const char **argv)
-{
-    CU_pSuite suite;
-    CU_pTest pTest;
-    unsigned int num_failures;
-    cu_run_mode cunit_mode = CUNIT_SCREEN;
-    int error_num;
-
-    if (argc > 1) {
-        cunit_mode = atoi(argv[1]);
-    }
-
-    if (CU_initialize_registry() != CUE_SUCCESS) {
-        return -CU_get_error();
-    }
-
-    suite = CU_add_suite("etmem_project_ops", NULL, NULL);
-    if (suite == NULL) {
-        goto ERROR;
-    }
-
-    if (CU_ADD_TEST(suite, test_etmem_prj_add_error) == NULL ||
-        CU_ADD_TEST(suite, test_etmem_prj_del_error) == NULL ||
-        CU_ADD_TEST(suite, test_etmem_project_add_ok) == NULL ||
-        CU_ADD_TEST(suite, test_etmem_mig_start_error) == NULL ||
-        CU_ADD_TEST(suite, test_etmem_mig_stop_error) == NULL ||
-        CU_ADD_TEST(suite, test_etmem_mig_start_ok) == NULL) {
-            printf("CU_ADD_TEST fail. \n");
-            goto ERROR;
-    }
-
-    switch (cunit_mode) {
-        case CUNIT_SCREEN:
-            CU_basic_set_mode(CU_BRM_VERBOSE);
-            CU_basic_run_tests();
-            break;
-        case CUNIT_XMLFILE:
-            CU_set_output_filename("etmemd_project.c");
-            CU_automated_run_tests();
-            break;
-        case CUNIT_CONSOLE:
-            CU_console_run_tests();
-            break;
-        default:
-            printf("not support cunit mode, only support: 0 or 1\n");
-            goto ERROR;
-    }
-
-    num_failures = CU_get_number_of_failures();
-    CU_cleanup_registry();
-    return num_failures;
-
-ERROR:
-    error_num = CU_get_error();
-    CU_cleanup_registry();
-    return -error_num;
-}
-- 
1.8.3.1

