From 692c7b671b87dd6cc3748426ab22d07b5330ad79 Mon Sep 17 00:00:00 2001
From: liubo <liubo254@huawei.com>
Date: Mon, 24 Jan 2022 06:42:23 +0800
Subject: [PATCH 22/33] etmem: add code of testcase

add code of testcase for etmem task function
add code of testcase for etmem thirdparty function

Signed-off-by: liubo <liubo254@huawei.com>
---
 .../test/etmem_socket_ops_llt_test/CMakeLists.txt  |   2 +-
 etmem/test/etmem_task_ops_llt_test/CMakeLists.txt  |  26 ++
 .../etmem_task_ops_llt_test/etmem_task_ops_llt.c   | 334 ++++++++++++++++
 .../etmem_thirdparty_ops_llt_test/CMakeLists.txt   |  30 ++
 .../etmem_thirdparty_ops_llt.c                     | 425 +++++++++++++++++++++
 .../test/etmem_thirdparty_ops_llt_test/my_engine.c | 156 ++++++++
 6 files changed, 972 insertions(+), 1 deletion(-)
 create mode 100644 etmem/test/etmem_task_ops_llt_test/CMakeLists.txt
 create mode 100644 etmem/test/etmem_task_ops_llt_test/etmem_task_ops_llt.c
 create mode 100644 etmem/test/etmem_thirdparty_ops_llt_test/CMakeLists.txt
 create mode 100644 etmem/test/etmem_thirdparty_ops_llt_test/etmem_thirdparty_ops_llt.c
 create mode 100644 etmem/test/etmem_thirdparty_ops_llt_test/my_engine.c

diff --git a/etmem/test/etmem_socket_ops_llt_test/CMakeLists.txt b/etmem/test/etmem_socket_ops_llt_test/CMakeLists.txt
index 7cc5343..05239a0 100644
--- a/etmem/test/etmem_socket_ops_llt_test/CMakeLists.txt
+++ b/etmem/test/etmem_socket_ops_llt_test/CMakeLists.txt
@@ -10,7 +10,7 @@
 #  * See the Mulan PSL v2 for more details.
 #  * Author: liubo
 #  * Create: 2021-12-10
-#  * Description: CMakefileList for etmem_log_ops_llt to compile
+#  * Description: CMakefileList for etmem_socket_ops_llt to compile
 #  ******************************************************************************/
 
 project(etmem)
diff --git a/etmem/test/etmem_task_ops_llt_test/CMakeLists.txt b/etmem/test/etmem_task_ops_llt_test/CMakeLists.txt
new file mode 100644
index 0000000..ab22dd6
--- /dev/null
+++ b/etmem/test/etmem_task_ops_llt_test/CMakeLists.txt
@@ -0,0 +1,26 @@
+s# /******************************************************************************
+#  * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+#  * etmem is licensed under the Mulan PSL v2.
+#  * You can use this software according to the terms and conditions of the Mulan PSL v2.
+#  * You may obtain a copy of Mulan PSL v2 at:
+#  *     http://license.coscl.org.cn/MulanPSL2
+#  * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+#  * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+#  * PURPOSE.
+#  * See the Mulan PSL v2 for more details.
+#  * Author: liubo
+#  * Create: 2021-12-10
+#  * Description: CMakefileList for etmem_task_ops_llt to compile
+#  ******************************************************************************/
+
+project(etmem)
+
+INCLUDE_DIRECTORIES(../../inc/etmem_inc)
+INCLUDE_DIRECTORIES(../../inc/etmemd_inc)
+INCLUDE_DIRECTORIES(${GLIB2_INCLUDE_DIRS})
+
+SET(EXE etmem_task_ops_llt)
+
+add_executable(${EXE} etmem_task_ops_llt.c)
+
+target_link_libraries(${EXE} cunit ${BUILD_DIR}/lib/libetmemd.so pthread dl rt boundscheck numa ${GLIB2_LIBRARIES})
diff --git a/etmem/test/etmem_task_ops_llt_test/etmem_task_ops_llt.c b/etmem/test/etmem_task_ops_llt_test/etmem_task_ops_llt.c
new file mode 100644
index 0000000..7997108
--- /dev/null
+++ b/etmem/test/etmem_task_ops_llt_test/etmem_task_ops_llt.c
@@ -0,0 +1,334 @@
+/******************************************************************************
+ * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+ * etmem is licensed under the Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ * http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+ * PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Author: liubo
+ * Create: 2021-12-10
+ * Description: This is a source file of the unit test for task functions in etmem.
+ ******************************************************************************/
+
+#include <sys/file.h>
+#include <sys/prctl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <glib.h>
+
+#include <CUnit/Basic.h>
+#include <CUnit/Automated.h>
+#include <CUnit/Console.h>
+
+#include "etmemd_project.h"
+#include "etmemd_task.h"
+#include "etmemd_engine.h"
+#include "etmemd_slide.h"
+#include "etmemd_cslide.h"
+#include "etmemd_rpc.h"
+#include "securec.h"
+
+#define PID_STR_MAX_LEN         10
+#define PID_TEST_NUM            100
+#define PID_PROCESS_MEM         5000
+#define PID_PROCESS_SLEEP_TIME  60
+#define WATER_LINT_TEMP         3
+
+static void get_task_pids_errinput(char *pid_val, char *pid_type, int exp)
+{
+    struct task *tk = NULL;
+
+    tk = (struct task *)calloc(1, sizeof(struct task));
+    CU_ASSERT_PTR_NOT_NULL(tk);
+
+    tk->type = pid_type;
+    tk->value = pid_val;
+    CU_ASSERT_EQUAL(etmemd_get_task_pids(tk, true), exp);
+
+    free(tk);
+}
+
+static void test_get_task_pids_error(void)
+{
+    get_task_pids_errinput("", "", -1);
+    get_task_pids_errinput("1", "", -1);
+    get_task_pids_errinput("no123", "pid", -1);
+    get_task_pids_errinput("1", "wrong", -1);
+    get_task_pids_errinput("wrong", "name", -1);
+    get_task_pids_errinput("-1", "pid", -1);
+}
+
+static void add_process(int index)
+{
+    int pid = fork();
+    switch (pid) {
+        case 0: /* child process */
+        {
+            char index_str[PID_PROCESS_MEM] = {0};
+            if (snprintf_s(index_str, PID_PROCESS_MEM, PID_PROCESS_MEM - 1, "%d", index) <= 0) {
+                printf("get index error.\n");
+            }
+            prctl(PR_SET_NAME, index_str, NULL, NULL, NULL);
+            sleep(PID_PROCESS_SLEEP_TIME);
+            exit(0);
+        }
+        case -1: /* create process wrong */
+        {
+            printf("[Worker]: Fork failed!\n");
+            exit(0);
+        }
+    
+        default:
+            break;
+    }
+}
+
+static int get_pids(int index)
+{
+    int pid = getpid();
+    int i;
+    for (i = 0; i < index; i++) {
+        add_process(i);
+    }
+    return pid;
+}
+
+static int init_ops(struct task *tk)
+{
+    tk->eng->ops->fill_eng_params = NULL;
+    tk->eng->ops->clear_eng_params = NULL;
+    tk->eng->ops->fill_task_params = NULL;
+    tk->eng->ops->clear_task_params = NULL;
+    tk->eng->ops->start_task = NULL;
+    tk->eng->ops->stop_task = NULL;
+    tk->eng->ops->alloc_pid_params = NULL;
+    tk->eng->ops->free_pid_params = NULL;
+    tk->eng->ops->eng_mgt_func = NULL;
+}
+
+static struct task *alloc_task(const char *pid_type, const char *pid_val)
+{
+    size_t pid_type_len;
+    size_t pid_value_len;
+    struct task *tk = NULL;
+
+    tk = (struct task *)calloc(1, sizeof(struct task));
+    CU_ASSERT_PTR_NOT_NULL(tk);
+
+    pid_type_len = strlen(pid_type) + 1;
+    pid_value_len = strlen(pid_val) + 1;
+
+    tk->type = (char *)calloc(pid_type_len, sizeof(char));
+    CU_ASSERT_PTR_NOT_NULL(tk->type);
+    if (strncpy_s(tk->type, pid_type_len, pid_type, pid_type_len - 1) != EOK) {
+        free(tk->type);
+        free(tk);
+        return NULL;
+    }
+
+    tk->value = (char *)calloc(pid_value_len, sizeof(char));
+    CU_ASSERT_PTR_NOT_NULL(tk->value);
+    if (strncpy_s(tk->value, pid_value_len, pid_val, pid_value_len - 1) != EOK) {
+        free(tk->type);
+        free(tk->value);
+        free(tk);
+        return NULL;
+    }
+
+    tk->eng = (struct engine *)calloc(1, sizeof(struct engine));
+    CU_ASSERT_PTR_NOT_NULL(tk->eng);
+    tk->eng->tasks = (void *)tk;
+
+    tk->eng->ops = (struct engine_ops *)calloc(1, sizeof(struct engine_ops));
+    CU_ASSERT_PTR_NOT_NULL(tk->eng->ops);
+    init_ops(tk);
+
+    CU_ASSERT_EQUAL(fill_engine_type_slide(tk->eng, NULL), 0);
+
+    return tk;
+}
+
+static void test_get_task_withpid_ok(void)
+{
+    char pid_val[PID_STR_MAX_LEN] = {0};
+    char *pid_type = "pid";
+    struct task *tk = NULL;
+    struct engine *eng = NULL;
+    int pid;
+
+    pid = get_pids((int)PID_TEST_NUM);
+    if (snprintf_s(pid_val, PID_STR_MAX_LEN, PID_STR_MAX_LEN - 1, "%d", pid) <= 0) {
+        printf("snprintf pid fail %d", pid);
+        return;
+    }
+    tk = alloc_task(pid_type, pid_val);
+    CU_ASSERT_PTR_NOT_NULL(tk);
+
+    CU_ASSERT_EQUAL(etmemd_get_task_pids(tk, true), 0);
+    CU_ASSERT_PTR_NOT_NULL(tk->pids);
+
+    etmemd_free_task_pids(tk);
+    CU_ASSERT_PTR_NULL(tk->pids);
+
+    etmemd_free_task_struct(&tk);
+    CU_ASSERT_PTR_NULL(tk);
+}
+
+static void test_get_task_withname_ok(void)
+{
+    char *pid_val = "systemd";
+    char *pid_type = "name";
+    struct task *tk = NULL;
+
+    tk = alloc_task(pid_type, pid_val);
+
+    CU_ASSERT_EQUAL(etmemd_get_task_pids(tk, true), 0);
+    CU_ASSERT_PTR_NOT_NULL(tk->pids);
+
+    etmemd_free_task_pids(tk);
+    CU_ASSERT_PTR_NULL(tk->pids);
+
+    etmemd_free_task_struct(&tk);
+    CU_ASSERT_PTR_NULL(tk);
+}
+
+static int get_task_pid(char *type, char *value, struct task *tk)
+{
+    char pid[PID_STR_MAX_LEN] = {0};
+    tk->type = type;
+    tk->value = value;
+    return get_pid_from_task_type(tk, pid);
+}
+
+static void test_get_pid_error(void)
+{
+    struct task *tk = NULL;
+
+    tk = (struct task *)calloc(1, sizeof(struct task));
+    CU_ASSERT_PTR_NOT_NULL(tk);
+
+    CU_ASSERT_EQUAL(get_task_pid("", "", tk), -1);
+    CU_ASSERT_EQUAL(get_task_pid("wrong", "", tk), -1);
+    CU_ASSERT_EQUAL(get_task_pid("", "no123", tk), -1);
+    CU_ASSERT_EQUAL(get_task_pid("pid", "no123", tk), 0);
+    CU_ASSERT_EQUAL(get_task_pid("name", "wrong", tk), -1);
+    free(tk);
+}
+
+static void test_get_pid_ok(void)
+{
+    struct task *tk = NULL;
+
+    tk = (struct task *)calloc(1, sizeof(struct task));
+    CU_ASSERT_PTR_NOT_NULL(tk);
+
+    CU_ASSERT_EQUAL(get_task_pid("pid", "1", tk), 0);
+    CU_ASSERT_EQUAL(get_task_pid("name", "systemd", tk), 0);
+    free(tk);
+}
+
+static void test_free_task_pids(void)
+{
+    struct task *tk = NULL;
+    struct task_pid *tk_pid = NULL;
+    struct slide_params *s_param = NULL;
+    struct engine *eng = NULL;
+
+    tk = (struct task *)calloc(1, sizeof(struct task));
+    CU_ASSERT_PTR_NOT_NULL(tk);
+
+    tk_pid = (struct task_pid *)calloc(1, sizeof(struct task_pid));
+    CU_ASSERT_PTR_NOT_NULL(tk_pid);
+    tk_pid->pid = 1;
+
+    s_param = (struct slide_params *)calloc(1, sizeof(struct slide_params));
+    CU_ASSERT_PTR_NOT_NULL(s_param);
+    s_param->t = WATER_LINT_TEMP;
+    tk_pid->params = s_param;
+    tk_pid->tk = tk;
+    tk->pids = tk_pid;
+
+    /* add engine */
+    eng = (struct engine *)calloc(1, sizeof(struct engine));
+    CU_ASSERT_PTR_NOT_NULL(eng);
+    tk->eng = eng;
+
+    tk->eng->ops = (struct engine_ops *)calloc(1, sizeof(struct engine_ops));
+    CU_ASSERT_PTR_NOT_NULL(tk->eng->ops);
+    init_ops(tk);
+
+    etmemd_free_task_pids(tk);
+    CU_ASSERT_PTR_NULL(tk->pids);
+    free(tk);
+    tk = NULL;
+}
+
+typedef enum {
+    CUNIT_SCREEN = 0,
+    CUNIT_XMLFILE,
+    CUNIT_CONSOLE
+} cu_run_mode;
+
+int main(int argc, const char **argv)
+{
+    CU_pSuite suite;
+    CU_pTest pTest;
+    unsigned int num_failures;
+    cu_run_mode cunit_mode = CUNIT_SCREEN;
+    int error_num;
+
+    if (argc > 1) {
+        cunit_mode = atoi(argv[1]);
+    }
+
+    if (CU_initialize_registry() != CUE_SUCCESS) {
+        return -CU_get_error();
+    }
+
+    suite = CU_add_suite("etmem_task_ops", NULL, NULL);
+    if (suite == NULL) {
+        goto ERROR;
+    }
+
+    if (CU_ADD_TEST(suite, test_get_task_pids_error) == NULL ||
+        CU_ADD_TEST(suite, test_get_task_withpid_ok) == NULL ||
+        CU_ADD_TEST(suite, test_get_task_withname_ok) == NULL ||
+        CU_ADD_TEST(suite, test_get_pid_error) == NULL ||
+        CU_ADD_TEST(suite, test_get_pid_ok) == NULL ||
+        CU_ADD_TEST(suite, test_free_task_pids) == NULL) {
+            printf("CU_ADD_TEST fail. \n");
+            goto ERROR;
+    }
+
+    switch (cunit_mode) {
+        case CUNIT_SCREEN:
+            CU_basic_set_mode(CU_BRM_VERBOSE);
+            CU_basic_run_tests();
+            break;
+        case CUNIT_XMLFILE:
+            CU_set_output_filename("etmemd_task.c");
+            CU_automated_run_tests();
+            break;
+        case CUNIT_CONSOLE:
+            CU_console_run_tests();
+            break;
+        default:
+            printf("not support cunit mode, only support: "
+                   "0 for CUNIT_SCREEN, 1 for CUNIT_XMLFILE, 2 for CUNIT_CONSOLE\n");
+            goto ERROR;
+    }
+
+    num_failures = CU_get_number_of_failures();
+    CU_cleanup_registry();
+    return num_failures;
+
+ERROR:
+    error_num = CU_get_error();
+    CU_cleanup_registry();
+    return -error_num;
+}
diff --git a/etmem/test/etmem_thirdparty_ops_llt_test/CMakeLists.txt b/etmem/test/etmem_thirdparty_ops_llt_test/CMakeLists.txt
new file mode 100644
index 0000000..6e82870
--- /dev/null
+++ b/etmem/test/etmem_thirdparty_ops_llt_test/CMakeLists.txt
@@ -0,0 +1,30 @@
+# /******************************************************************************
+#  * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+#  * etmem is licensed under the Mulan PSL v2.
+#  * You can use this software according to the terms and conditions of the Mulan PSL v2.
+#  * You may obtain a copy of Mulan PSL v2 at:
+#  *     http://license.coscl.org.cn/MulanPSL2
+#  * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+#  * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+#  * PURPOSE.
+#  * See the Mulan PSL v2 for more details.
+#  * Author: liubo
+#  * Create: 2021-12-10
+#  * Description: CMakefileList for etmem_thirdparty_ops_llt to compile
+#  ******************************************************************************/
+
+project(etmem)
+
+INCLUDE_DIRECTORIES(../../inc/etmem_inc)
+INCLUDE_DIRECTORIES(../../inc/etmemd_inc)
+INCLUDE_DIRECTORIES(../common)
+INCLUDE_DIRECTORIES(${GLIB2_INCLUDE_DIRS})
+
+SET(EXE etmem_thirdparty_ops_llt)
+SET(LIB thirdparty_engine)
+
+add_library(${LIB} SHARED my_engine.c)
+add_executable(${EXE} etmem_thirdparty_ops_llt.c)
+
+target_link_libraries(${EXE} ${LIB} ${LIBNULL} cunit ${BUILD_DIR}/lib/libetmemd.so 
+                      ${BUILD_DIR}/lib/libtest.so pthread dl rt boundscheck numa ${GLIB2_LIBRARIES})
diff --git a/etmem/test/etmem_thirdparty_ops_llt_test/etmem_thirdparty_ops_llt.c b/etmem/test/etmem_thirdparty_ops_llt_test/etmem_thirdparty_ops_llt.c
new file mode 100644
index 0000000..d7e7ae4
--- /dev/null
+++ b/etmem/test/etmem_thirdparty_ops_llt_test/etmem_thirdparty_ops_llt.c
@@ -0,0 +1,425 @@
+/******************************************************************************
+ * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+ * etmem is licensed under the Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ * http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+ * PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Author: liubo
+ * Create: 2021-12-10
+ * Description: This is a source file of the unit test for thirdparty functions in etmem.
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <CUnit/Basic.h>
+#include <CUnit/Automated.h>
+#include <CUnit/Console.h>
+
+#include "test_common.h"
+#include "etmemd_thirdparty_export.h"
+#include "etmemd_project.h"
+
+#define CONFIG_ENGINE_NAME          "eng_name=%s\n"
+#define CONFIG_LIBNAME              "libname=%s\n"
+#define CONFIG_OPS_NAME             "ops_name=%s\n"
+#define CONFIG_ENGINE_PRIVATE_KEY   "engine_private_key=%s\n"
+
+#define CONFIG_TASK_PRIVATE_KEY     "task_private_key=%s\n"
+
+struct thirdparty_eng_param {
+    struct eng_test_param eng_param;
+    const char *engine_name;
+    const char *libname;
+    const char *ops_name;
+    const char *engine_private_key;
+};
+
+struct thirdparty_task_param {
+    struct task_test_param task_param;
+    const char *task_private_key;
+};
+
+static struct proj_test_param g_proj_param;
+
+static void init_thirdparty_eng(struct thirdparty_eng_param *param, 
+                                const char *libname, const char *ops_name)
+{
+    param->eng_param.name = "thirdparty";
+    param->eng_param.proj = DEFAULT_PROJ;
+    param->eng_param.file_name = TMP_TASK_CONFIG;
+    param->engine_name = "my_engine";
+    param->libname = libname;
+    param->ops_name = ops_name;
+    param->engine_private_key = "1024";
+}
+
+static void add_thirdparty_eng(struct thirdparty_eng_param *param)
+{
+    FILE *file = NULL;
+    const char *file_name = param->eng_param.file_name;
+
+    file = fopen(file_name, "a+");
+    CU_ASSERT_PTR_NOT_NULL(file);
+    CU_ASSERT_NOT_EQUAL(fprintf(file, CONFIG_ENGINE_NAME, param->engine_name), -1);
+    CU_ASSERT_NOT_EQUAL(fprintf(file, CONFIG_LIBNAME, param->libname), -1);
+    CU_ASSERT_NOT_EQUAL(fprintf(file, CONFIG_OPS_NAME, param->ops_name), -1);
+    CU_ASSERT_NOT_EQUAL(fprintf(file, CONFIG_ENGINE_PRIVATE_KEY, param->engine_private_key), -1);
+    fclose(file);
+}
+
+static GKeyFile *construct_thirdparty_eng_config(struct thirdparty_eng_param *param)
+{
+    struct eng_test_param *eng_param = &param->eng_param;
+
+    construct_eng_file(eng_param);
+    add_thirdparty_eng(param);
+
+    return load_config(eng_param->file_name);
+}
+
+static void destroy_thirdparty_eng_config(GKeyFile *config)
+{
+    unload_config(config);
+}
+
+static void init_thirdparty_task(struct thirdparty_task_param *param)
+{
+    init_task_param(&param->task_param, "my_engine");
+    param->task_private_key = "2048";
+}
+
+static void add_thirdparty_task(struct thirdparty_task_param *param)
+{
+    FILE *file = NULL;
+    const char *file_name = param->task_param.file_name;
+
+    file = fopen(file_name, "a+");
+    CU_ASSERT_PTR_NOT_NULL(file);
+    CU_ASSERT_NOT_EQUAL(fprintf(file, CONFIG_TASK_PRIVATE_KEY, param->task_private_key), -1);
+    fclose(file);
+}
+
+static GKeyFile *construct_thirdparty_task_config(struct thirdparty_task_param *param)
+{
+    struct task_test_param *task_param = &param->task_param;
+
+    construct_task_file(task_param);
+    add_thirdparty_task(param);
+
+    return load_config(task_param->file_name);
+}
+
+static void destroy_thirdparty_task_config(GKeyFile *config)
+{
+    unload_config(config);
+}
+
+static void test_init(void)
+{
+    init_proj_param(&g_proj_param);
+    do_add_proj_test(&g_proj_param);
+}
+
+static void test_fini(void)
+{
+    do_rm_proj_test(&g_proj_param);
+}
+
+static void test_etmem_mgt_engine_error(void)
+{
+    CU_ASSERT_EQUAL(etmemd_project_mgt_engine(NULL, NULL, NULL, DEFAULT_TASK, 0), OPT_INVAL);
+}
+
+void test_etmem_user_engine_0001(void)
+{
+    struct thirdparty_eng_param thirdparty_engine_param;
+    struct thirdparty_task_param thirdparty_task_param;
+    GKeyFile *eng_config = NULL;
+    GKeyFile *task_config = NULL;
+
+    test_init();
+
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "my_engine_ops");
+    init_thirdparty_task(&thirdparty_task_param);
+
+    eng_config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+
+    task_config = construct_thirdparty_task_config(&thirdparty_task_param);
+    CU_ASSERT_EQUAL(etmemd_project_add_task(task_config), OPT_SUCCESS);
+
+    CU_ASSERT_EQUAL(etmemd_migrate_start(DEFAULT_PROJ), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_mgt_engine(DEFAULT_PROJ, "my_engine", 
+                                              "my_cmd", DEFAULT_TASK, 0), OPT_SUCCESS);
+
+    /* test param NULL */
+    CU_ASSERT_EQUAL(etmemd_project_mgt_engine(NULL, NULL, 
+                                              NULL, DEFAULT_TASK, 0), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_mgt_engine(DEFAULT_PROJ, "no_exist_engine", 
+                                              "my_cmd", DEFAULT_TASK, 0), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_mgt_engine(DEFAULT_PROJ, "my_engine", 
+                                              "my_cmd", "no_exist_task", 0), OPT_SUCCESS);
+
+    CU_ASSERT_EQUAL(etmemd_migrate_stop(DEFAULT_PROJ), OPT_SUCCESS);
+
+    /* test for project not start */
+    CU_ASSERT_EQUAL(etmemd_project_mgt_engine(DEFAULT_PROJ, "my_engine", 
+                                              "my_cmd", DEFAULT_TASK, 0), OPT_INVAL);
+
+    CU_ASSERT_EQUAL(etmemd_project_remove_task(task_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove_engine(eng_config), OPT_SUCCESS);
+
+    destroy_thirdparty_task_config(task_config);
+    destroy_thirdparty_eng_config(eng_config);
+
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "start_error_ops");
+    init_thirdparty_task(&thirdparty_task_param);
+
+    eng_config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+
+    task_config = construct_thirdparty_task_config(&thirdparty_task_param);
+    /* start task fail when start projecct */
+    CU_ASSERT_EQUAL(etmemd_project_add_task(task_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_start(DEFAULT_PROJ), OPT_INTER_ERR);
+    CU_ASSERT_EQUAL(etmemd_project_remove_task(task_config), OPT_SUCCESS);
+
+    /* add task fail if project is already start */
+    CU_ASSERT_EQUAL(etmemd_migrate_start(DEFAULT_PROJ), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_add_task(task_config), OPT_INTER_ERR);
+
+    destroy_thirdparty_task_config(task_config);
+    destroy_thirdparty_eng_config(eng_config);
+
+    test_fini();
+}
+
+static void test_etmem_user_engine_null(void)
+{
+    struct thirdparty_eng_param thirdparty_engine_param;
+    struct thirdparty_task_param thirdparty_task_param;
+    GKeyFile *eng_config = NULL;
+    GKeyFile *task_config = NULL;
+
+    test_init();
+
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "start_not_null_ops");
+    init_thirdparty_task(&thirdparty_task_param);
+
+    eng_config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    task_config = construct_thirdparty_task_config(&thirdparty_task_param);
+
+    /* only start task is not null to cover null mgt and stop */
+    CU_ASSERT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_add_task(task_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_start(DEFAULT_PROJ), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_mgt_engine(DEFAULT_PROJ, "my_engine", 
+                                              "my_cmd", DEFAULT_TASK, 0), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_stop(DEFAULT_PROJ), OPT_SUCCESS);
+
+    CU_ASSERT_EQUAL(etmemd_project_remove_task(task_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove_engine(eng_config), OPT_SUCCESS);
+
+    destroy_thirdparty_task_config(task_config);
+    destroy_thirdparty_eng_config(eng_config);
+
+    test_fini();
+
+    test_init();
+
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "start_null_ops");
+    init_thirdparty_task(&thirdparty_task_param);
+
+    eng_config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    task_config = construct_thirdparty_task_config(&thirdparty_task_param);
+
+    /* start task manually */
+    CU_ASSERT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_add_task(task_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_start(DEFAULT_PROJ), OPT_INTER_ERR);
+    CU_ASSERT_EQUAL(etmemd_project_remove_task(task_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove_engine(eng_config), OPT_SUCCESS);
+
+    /* start task auto (project is already start when add a task) */
+    CU_ASSERT_EQUAL(etmemd_migrate_start(DEFAULT_PROJ), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_add_task(task_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove_engine(eng_config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_migrate_stop(DEFAULT_PROJ), OPT_SUCCESS);
+
+    destroy_thirdparty_task_config(task_config);
+    destroy_thirdparty_eng_config(eng_config);
+
+    test_fini();
+}
+
+static void test_etmem_invalid_config(void)
+{
+    struct thirdparty_eng_param thirdparty_engine_param;
+    GKeyFile *eng_config = NULL;
+
+    test_init();
+
+    /* test invalid so */
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/invalid.so", "my_engine_ops");
+    eng_config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_NOT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+    destroy_thirdparty_eng_config(eng_config);
+
+    /* test invalid engine name */
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "my_engine_ops");
+    thirdparty_engine_param.engine_name = "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";
+    eng_config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_NOT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+    destroy_thirdparty_eng_config(eng_config);
+
+    /* test invalid ops */
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "no_exist_ops");
+    eng_config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_NOT_EQUAL(etmemd_project_add_engine(eng_config), OPT_SUCCESS);
+    destroy_thirdparty_eng_config(eng_config);
+
+    test_fini();
+}
+
+void test_etmem_user_engine_0002(void)
+{
+    test_etmem_user_engine_null();
+}
+
+/* add correct thirdparty config */
+void test_etmem_add_thirdparty_0001(void)
+{
+    struct thirdparty_eng_param thirdparty_engine_param;
+    GKeyFile *config = NULL;
+
+    test_init();
+
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "my_engine_ops");
+    config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_EQUAL(etmemd_project_add_engine(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove_engine(config), OPT_SUCCESS);
+    destroy_thirdparty_eng_config(config);
+
+    test_fini();
+}
+
+/* add wrong thirdparty config */
+void test_etmem_add_thirdparty_0002(void)
+{
+    test_etmem_invalid_config();
+}
+
+/* del correct thirdparty config */
+void test_etmem_del_thirdparty_0001(void)
+{
+    struct thirdparty_eng_param thirdparty_engine_param;
+    GKeyFile *config = NULL;
+
+    test_init();
+
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "my_engine_ops");
+    config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_EQUAL(etmemd_project_add_engine(config), OPT_SUCCESS);
+    CU_ASSERT_EQUAL(etmemd_project_remove_engine(config), OPT_SUCCESS);
+    destroy_thirdparty_eng_config(config);
+
+    test_fini();
+}
+
+/* del wrong thirdparty config */
+void test_etmem_del_thirdparty_0002(void)
+{
+    struct thirdparty_eng_param thirdparty_engine_param;
+    GKeyFile *config = NULL;
+
+    test_init();
+
+    /* del no exist engine */
+    init_thirdparty_eng(&thirdparty_engine_param, "./lib/libthirdparty_engine.so", "my_engine_ops");
+    config = construct_thirdparty_eng_config(&thirdparty_engine_param);
+    CU_ASSERT_EQUAL(etmemd_project_remove_engine(config), OPT_ENG_NOEXIST);
+    destroy_thirdparty_eng_config(config);
+
+    test_fini();
+}
+
+void do_rm_proj_test(struct proj_test_param *param)
+{
+    GKeyFile *config = NULL;
+
+    config = load_config(param->file_name);
+    CU_ASSERT_EQUAL(etmemd_project_remove(config), param->expt);
+    unload_config(config);
+}
+
+typedef enum {
+    CUNIT_SCREEN = 0,
+    CUNIT_XMLFILE,
+    CUNIT_CONSOLE
+} cu_run_mode;
+
+int main(int argc, const char **argv)
+{
+    CU_pSuite suite;
+    CU_pTest pTest;
+    unsigned int num_failures;
+    cu_run_mode cunit_mode = CUNIT_SCREEN;
+    int error_num;
+
+    if (argc > 1) {
+        cunit_mode = atoi(argv[1]);
+    }
+
+    if (CU_initialize_registry() != CUE_SUCCESS) {
+        return -CU_get_error();
+    }
+
+    suite = CU_add_suite("etmem_thirdparty_ops", NULL, NULL);
+    if (suite == NULL) {
+        goto ERROR;
+    }
+
+    if (CU_ADD_TEST(suite, test_etmem_user_engine_0001) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_user_engine_0002) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_add_thirdparty_0001) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_add_thirdparty_0002) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_del_thirdparty_0001) == NULL ||
+        CU_ADD_TEST(suite, test_etmem_del_thirdparty_0002) == NULL) {
+            printf("CU_ADD_TEST fail. \n");
+            goto ERROR;
+    }
+
+    switch (cunit_mode) {
+        case CUNIT_SCREEN:
+            CU_basic_set_mode(CU_BRM_VERBOSE);
+            CU_basic_run_tests();
+            break;
+        case CUNIT_XMLFILE:
+            CU_set_output_filename("etmemd_thirdparty.c");
+            CU_automated_run_tests();
+            break;
+        case CUNIT_CONSOLE:
+            CU_console_run_tests();
+            break;
+        default:
+            printf("not support cunit mode, only support: "
+                   "0 for CUNIT_SCREEN, 1 for CUNIT_XMLFILE, 2 for CUNIT_CONSOLE\n");
+            goto ERROR;
+    }
+
+    num_failures = CU_get_number_of_failures();
+    CU_cleanup_registry();
+    return num_failures;
+
+ERROR:
+    error_num = CU_get_error();
+    CU_cleanup_registry();
+    return -error_num;
+}
diff --git a/etmem/test/etmem_thirdparty_ops_llt_test/my_engine.c b/etmem/test/etmem_thirdparty_ops_llt_test/my_engine.c
new file mode 100644
index 0000000..bd2a3bc
--- /dev/null
+++ b/etmem/test/etmem_thirdparty_ops_llt_test/my_engine.c
@@ -0,0 +1,156 @@
+/******************************************************************************
+ * Copyright (c) Huawei Technologies Co., Ltd. 2019-2021. All rights reserved.
+ * etmem is licensed under the Mulan PSL v2.
+ * You can use this software according to the terms and conditions of the Mulan PSL v2.
+ * You may obtain a copy of Mulan PSL v2 at:
+ * http://license.coscl.org.cn/MulanPSL2
+ * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+ * PURPOSE.
+ * See the Mulan PSL v2 for more details.
+ * Author: liubo
+ * Create: 2021-12-10
+ * Description: This is a source file of the unit test for task functions in etmem.
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "etmemd_thirdparty_export.h"
+
+char *get_private_value(GKeyFile *config, char *group, char *key)
+{
+    if (g_key_file_has_key(config, group, key, NULL) == FALSE) {
+        return NULL;
+    }
+
+    return g_key_file_get_string(config, group, key, NULL);
+}
+
+char *get_params_str(void *str)
+{
+    return str == NULL ? "NULL" : (char *)str;
+}
+
+int fill_eng_params(GKeyFile *config, struct engine *eng)
+{
+    /* engine_private_key is user defined key name in engine group in config file */
+    eng->params = get_private_value(config, "engine", "engine_private_key");
+    if (strcmp(eng->params, "1024") != 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+void clear_eng_params(struct engine *eng)
+{
+    if (eng->params != NULL) {
+        free(eng->params);
+        eng->params = NULL;
+    }
+}
+
+int fill_task_params(GKeyFile *config, struct task *task)
+{
+    /* task_private_key is user defined key name in task group in config file */
+    task->params = get_private_value(config, "task", "task_private_key");
+    if (strcmp(task->params, "2048") != 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+void clear_task_params(struct task *task)
+{
+    if (task->params != NULL) {
+        free(task->params);
+        task->params = NULL;
+    }
+}
+
+int start_task(struct engine *eng, struct task *task)
+{
+    return 0;
+}
+
+static int my_start_task(struct engine *eng, struct task *tk)
+{
+    return 0;
+}
+
+int error_start_task(struct engine *eng, struct task *task)
+{
+    return -1;
+}
+
+void stop_task(struct engine *eng, struct task *task)
+{
+}
+
+int alloc_pid_params(struct engine *eng, struct task_pid **tk_pid)
+{
+    return 0;
+}
+
+void free_pid_params(struct engine *eng, struct task_pid **tk_pid)
+{
+}
+
+int eng_mgt_func(struct engine *eng, struct task *task, char *cmd, int fd)
+{
+    char *msg = "msg to client\n";
+
+    write(fd, msg, strlen(msg));
+    return 0;
+}
+
+struct engine_ops my_engine_ops = {
+    .fill_eng_params = fill_eng_params,
+    .clear_eng_params = clear_eng_params,
+    .fill_task_params = fill_task_params,
+    .clear_task_params = clear_task_params,
+    .start_task = start_task,
+    .stop_task = stop_task,
+    .alloc_pid_params = alloc_pid_params,
+    .free_pid_params = free_pid_params,
+    .eng_mgt_func = eng_mgt_func,
+};
+
+struct engine_ops start_error_ops = {
+    .fill_eng_params = fill_eng_params,
+    .clear_eng_params = clear_eng_params,
+    .fill_task_params = fill_task_params,
+    .clear_task_params = clear_task_params,
+    .start_task = error_start_task,
+    .stop_task = stop_task,
+    .alloc_pid_params = alloc_pid_params,
+    .free_pid_params = free_pid_params,
+    .eng_mgt_func = eng_mgt_func,
+};
+
+struct engine_ops start_not_null_ops = {
+    .fill_eng_params = NULL,
+    .clear_eng_params = NULL,
+    .fill_task_params = NULL,
+    .clear_task_params = NULL,
+    .start_task = my_start_task,
+    .stop_task = NULL,
+    .alloc_pid_params = NULL,
+    .free_pid_params = NULL,
+    .eng_mgt_func = NULL,
+};
+
+struct engine_ops start_null_ops = {
+    .fill_eng_params = NULL,
+    .clear_eng_params = NULL,
+    .fill_task_params = NULL,
+    .clear_task_params = NULL,
+    .start_task = NULL,
+    .stop_task = NULL,
+    .alloc_pid_params = NULL,
+    .free_pid_params = NULL,
+    .eng_mgt_func = NULL,
+};
-- 
1.8.3.1

